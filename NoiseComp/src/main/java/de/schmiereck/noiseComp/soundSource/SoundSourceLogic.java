package de.schmiereck.noiseComp.soundSource;

import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;

import de.schmiereck.noiseComp.generator.Generator;
import de.schmiereck.noiseComp.generator.GeneratorChangeListenerInterface;
import de.schmiereck.noiseComp.generator.InputData;
import de.schmiereck.noiseComp.generator.module.ModuleGeneratorTypeData;
import de.schmiereck.noiseComp.generator.signal.OutputGenerator;
import de.schmiereck.noiseComp.generator.SoundSample;
import de.schmiereck.noiseComp.soundData.SoundDataLogic;
import de.schmiereck.noiseComp.timeline.Timeline;
import de.schmiereck.noiseComp.timeline.TimelineChangedListernerInterface;
import de.schmiereck.noiseComp.timeline.TimelineManagerLogic;

/**
 * <p>
 * 	Manages a connection between the (Output) {@link Generator} of
 * 	the current selected Generators and the 
 * 	{@link SoundDataLogic}-Output.
 * </p>
 * <p>
 * 	Buffers the output.<br/>
 * 	The buffer is filled by a polling thread.<br/>
 * 	The affected parts of the buffer are cleard if changes in the input
 * 	are reported. 
 * </p>
 * <p>
 * Manages the actual Output-Generator and filles a buffer with his
 * pre calculated samples (by polling in a thread).
 * </p>
 * 
 * @author smk
 * @version <p>06.06.2004: created, smk</p>
 */
public class SoundSourceLogic
implements GeneratorChangeListenerInterface, 
		   TimelineChangedListernerInterface
{
	//**********************************************************************************************
	// Fields:
	
	/**
	 * Is the generator genarates the output samples.
	 * 
	 * TODO Remove this and only use {@link #outputTimeline}.
	 */
	private Generator outputGenerator = null;

	/**
	 * Output Timeline.
	 */
	private Timeline outputTimeline = null;

	/**
	 * Timeline-Manager Logic.
	 */
	private TimelineManagerLogic timelineManagerLogic = null;
	
	/**
	 * Is a buffer to store the output samples generated by {@link #outputGenerator}. 
	 */
	private SoundSamplesBufferData	soundSamplesBufferData;
	
	//**********************************************************************************************
	// Functions:
	
	/**
	 * Constructor.
	 *
	 */
	public SoundSourceLogic() // OutputGenerator outputGenerator
	{
		//this.outputGenerator = outputGenerator;

		this.soundSamplesBufferData = new SoundSamplesBufferData();
	}

	/**
	 * @param mainModuleGeneratorTypeData
	 * 			is the mainModuleGeneratorTypeData.
	 * @return
	 * 			the timelines.
	 */
	public synchronized List<Timeline> setMainModuleGeneratorTypeData(ModuleGeneratorTypeData mainModuleGeneratorTypeData)
	{
		//==========================================================================================
		List<Timeline> timelines = new Vector<Timeline>();
		
		//------------------------------------------------------------------------------------------
		this.timelineManagerLogic = new TimelineManagerLogic(this, mainModuleGeneratorTypeData);
		
		//------------------------------------------------------------------------------------------
		this.setOutputGenerator(null);
	
		this.outputTimeline = null;
		
		//------------------------------------------------------------------------------------------
		// Walk rekursive through inputs because we need existing timelines to create input timelines:
		
		OutputGenerator outputGenerator = mainModuleGeneratorTypeData.getOutputGenerator();
		
		if (outputGenerator != null)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			List<Timeline> inputTimelines = new Vector<Timeline>();
			
			this.createTimeline(inputTimelines, outputGenerator);
			
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// Sort timelines:

			Iterator<Generator> generatorsIterator = mainModuleGeneratorTypeData.getGeneratorsIterator();
			
			while (generatorsIterator.hasNext())
			{
				Generator generator = generatorsIterator.next();
				
				Timeline inputTimeline = this.searchInputTimeline(inputTimelines, generator);
				
				// Not connected generator?
				if (inputTimeline == null)
				{
					// Create this timeline.
					inputTimeline = this.timelineManagerLogic.createTimeline(generator);
				}
				
				timelines.add(inputTimeline);
			}
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		}
		
//		Iterator<Generator> generatorsIterator = mainModuleGeneratorTypeData.getGeneratorsIterator();
//		
//		while (generatorsIterator.hasNext())
//		{
//			Generator generator = generatorsIterator.next();
//			
//			Timeline timeline = 
//				this.timelineManagerLogic.createTimeline(generator);
//			
//			timelines.add(timeline);
//		}
		
		//------------------------------------------------------------------------------------------
		this.printDebug1(this.outputTimeline, 0);
		this.printDebug2(this.outputTimeline, 0);
		this.printDebug3(this.outputTimeline, 0, false);
		
		//==========================================================================================
		return timelines;
	}

	private void printDebug1(Timeline parentTimeline, int level)
	{
		for (int pos = 0; pos < level * 2; pos++)
		{
			System.out.print(' ');
		}
		System.out.println("DBG 1: " + parentTimeline);
		
		if (parentTimeline != null)
		{
			Iterator<InputData> inputsIterator = parentTimeline.getInputsIterator();
			
			if (inputsIterator != null)
			{
				while (inputsIterator.hasNext())
				{
					InputData inputData = inputsIterator.next();
	
					Timeline inputTimeline = (Timeline)parentTimeline.getInputGeneratorBuffer(inputData);
					
					if (inputTimeline != null)
					{
						this.printDebug1(inputTimeline, level + 1);
					}
				}
			}
		}
	}
	private void printDebug2(Timeline parentTimeline, int level)
	{
		for (int pos = 0; pos < level * 2; pos++)
		{
			System.out.print(' ');
		}
		System.out.println("DBG 2: " + parentTimeline);
		
		if (parentTimeline != null)
		{
			Collection<Timeline> timelines = parentTimeline.getInputTimelines().values();
			
			for (Timeline timeline : timelines)
			{
				this.printDebug2(timeline, level + 1);
			}
		}
	}


	private void printDebug3(Timeline parentTimeline, int level, boolean isSub)
	{
		for (int pos = 0; pos < level * 2; pos++)
		{
			System.out.print(' ');
		}
		if (isSub == true)
		{
			System.out.print("SUB ");
		}
		System.out.println("DBG 3: " + parentTimeline);
		
		if (parentTimeline != null)
		{
			Collection<Timeline> timelines = parentTimeline.getInputTimelines().values();
			
			for (Timeline timeline : timelines)
			{
				this.printDebug3(timeline, level + 1, false);
				
				for (Timeline subTimeline : timeline.getSubGeneratorTimelines())
				{
					this.printDebug3(subTimeline, level + 2, true);
				}
			}
		}
	}

	/**
	 * @param inputTimelines
	 * 			are the timelines.
	 * @param generator
	 * 			is the Generator.
	 * @return
	 * 			is the searched Timeline with given Generator.
	 */
	private Timeline searchInputTimeline(List<Timeline> inputTimelines, Generator generator)
	{
		//==========================================================================================
		Timeline retTimeline;
		
		retTimeline = null;
		
		for (Timeline timeline : inputTimelines)
		{
			if (timeline.getGenerator() == generator)
			{
				retTimeline = timeline;
				break;
			}
		}
		
		//==========================================================================================
		return retTimeline;
	}

	/**
	 * @param timelines
	 * 			are the timelines.
	 * @param generator
	 * 			is the generator.
	 */
	private void createTimeline(List<Timeline> timelines, Generator generator)
	{
		//==========================================================================================
		Iterator<InputData> inputsIterator = generator.getInputsIterator();
		
		if (inputsIterator != null)
		{
			while (inputsIterator.hasNext())
			{
				InputData inputData = inputsIterator.next();
				
				Generator inputGenerator = inputData.getInputGenerator();
				
				if (inputGenerator != null)
				{
					this.createTimeline(timelines, inputGenerator);
				}
			}
		}
		
		//------------------------------------------------------------------------------------------
		Timeline timeline = this.timelineManagerLogic.createTimeline(generator);
	
		timelines.add(timeline);
		
		//==========================================================================================
	}

	/**
	 * @param outputGenerator 
	 * 			to set {@link #outputGenerator}.
	 */
	public void setOutputGenerator(Generator outputGenerator)
	{
		//==========================================================================================
		if (this.outputGenerator != null)
		{
			this.outputGenerator.getGeneratorChangeObserver().removeGeneratorChangeListener(this);
		}
		
		this.outputGenerator = outputGenerator;
		
		if (this.outputGenerator != null)
		{
			float timeLen = this.outputGenerator.getEndTimePos() - this.outputGenerator.getStartTimePos();
			
			this.soundSamplesBufferData.createBuffer(timeLen, this.outputGenerator.getSoundFrameRate());
	
			this.outputGenerator.getGeneratorChangeObserver().registerGeneratorChangeListener(this);
		}		
		//==========================================================================================
	}

//	/**
//	 * @param generator
//	 * 			is the generator.
//	 * @return
//	 * 			the timeline.
//	 */
//	public Timeline getTimeline(Generator generator)
//	{
//		Timeline timeline = this.timelineManagerLogic.getTimeline(generator);
//		
//		return timeline;
//	}
	
	/**
	 * @return 
	 * 			the attribute {@link #outputGenerator}.
	 */
	public Generator getOutputGenerator()
	{
		return this.outputGenerator;
	}

	/**
	 * @return 
	 * 			returns the {@link #outputTimeline}.
	 */
	public Timeline getOutputTimeline()
	{
		return this.outputTimeline;
	}

	/**
	 * @param frame
	 * 			ist the sound sample frame.
	 * @return
	 * 			the sound sample.
	 */
	public SoundSample generateFrameSample(long frame)
	{
		SoundSample soundSample;
		
		//synchronized (this)
		{
			if (this.outputGenerator != null)
			{
				soundSample = this.soundSamplesBufferData.generateSoundSample(frame, this.outputTimeline);
			}
			else
			{
				soundSample = null;
			}
		}
		
		return soundSample;
	}
	
	/**
	 * @param frame
	 * 			ist the sound sample frame.
	 * @return
	 * 			the sound sample.
	 */
	public SoundSample getFrameSample(long frame)
	{
		SoundSample soundSample;
		
		//synchronized (this)
		{
			if (this.outputGenerator != null)
			{
				soundSample = this.soundSamplesBufferData.getSoundSample(frame);
			}
			else
			{
				soundSample = null;
			}
		}
		
		return soundSample;
	}

	/**
	 * Generates the next part of samples and store them in the buffer object {@link #soundSamplesBufferData}.
	 * 
	 * @param actualWaitPerFramesMillis
	 * 			are the Milliseconds to calculate.
	 */
	public void pollCalcFillBuffer(long actualWaitPerFramesMillis)
	{
		synchronized (this)
		{
			if (this.outputGenerator != null)
			{
				long emptyBuffer1Start = this.soundSamplesBufferData.getEmptyBufferStart();
				long emptyBuffer1End = this.soundSamplesBufferData.getEmptyBufferEnd();
				
				// Time in seconds.
				float timeSchedulerIsWaiting = (actualWaitPerFramesMillis / 1000.0F);
				
				float timeBufferIsFilled = timeSchedulerIsWaiting * 2.0F;
				
				boolean bufferCompletelyFilled =
					this.soundSamplesBufferData.calcWaitingSamplesPart(timeBufferIsFilled, 
																	   this.outputTimeline);
				
				if (bufferCompletelyFilled == true)
				{
					this.timelineManagerLogic.notifyBufferCompletelyFilled();
				}
				
				long emptyBuffer2Start = this.soundSamplesBufferData.getEmptyBufferStart();
				long emptyBuffer2End = this.soundSamplesBufferData.getEmptyBufferEnd();
				
				//long calcBufferStart;
				//long calcBufferEnd;
				
				if ((emptyBuffer1Start != emptyBuffer2Start) ||
					(emptyBuffer1End != emptyBuffer2End))
				{
					this.timelineManagerLogic.notifyTimelineContentChangedListeners(emptyBuffer1Start,
					                                                                emptyBuffer1End);
				}
			}
		}
	}

	public long getEmptyBufferStart()
	{
		long ret;
		
		if (this.soundSamplesBufferData != null)
		{
			ret = this.soundSamplesBufferData.getEmptyBufferStart();
		}
		else
		{
			ret = 0L;
		}
		
		return ret;
	}
	
	public long getEmptyBufferEnd()
	{
		long ret;
		
		if (this.soundSamplesBufferData != null)
		{
			ret = this.soundSamplesBufferData.getEmptyBufferEnd();
		}
		else
		{
			ret = 0L;
		}
		
		return ret;
	}

	public long getEmptyBufferSize()
	{
		long emptyBufferSize;
		
		emptyBufferSize = this.getEmptyBufferEnd() - this.getEmptyBufferStart();
		
		return emptyBufferSize;
	}

	/* (non-Javadoc)
	 * @see de.schmiereck.noiseComp.generator.GeneratorChangeListenerInterface#notifyGeneratorChanged(de.schmiereck.noiseComp.generator.Generator, float, float)
	 */
	public void notifyGeneratorChanged(Generator generator, float changedStartTimePos, float changedEndTimePos)
	{
		long bufferSamplesCount = this.soundSamplesBufferData.getBufferSamplesCount();

		float timeLen = this.outputGenerator.getEndTimePos(); // - this.outputGenerator.getStartTimePos();

		float frameRate = this.soundSamplesBufferData.getFrameRate();

		long newCamplesCount = (long)(timeLen * frameRate);
		
		System.out.println("SoundSourceLogic.notifyChanged: frameRate: generator(" + generator.getSoundFrameRate() + "), buffer(" + frameRate + ")");
		System.out.println("SoundSourceLogic.notifyChanged: oldBuffer(" + bufferSamplesCount + "), new(" + newCamplesCount + "), " + changedStartTimePos + ", " + changedEndTimePos + ")");
		
		if (newCamplesCount > bufferSamplesCount)
		{
			this.soundSamplesBufferData.createBuffer(timeLen, frameRate);
		}
		
		this.soundSamplesBufferData.clearBuffer(changedStartTimePos, changedEndTimePos);
	}

//	/**
//	 * @param generator
//	 * 			is the generator.
//	 * @return
//	 * 			the timeline.
//	 */
//	public Timeline addGenerator(Generator generator)
//	{
//		Timeline timeline = this.timelineManagerLogic.addGenerator(generator);
//		
//		return timeline;
//	}

	/**
	 * @return 
	 * 			returns the {@link #timelineManagerLogic}.
	 */
	public TimelineManagerLogic getTimelineManagerLogic()
	{
		return this.timelineManagerLogic;
	}

	/**
	 * @param outputTimeline 
	 * 			to set {@link #outputTimeline}.
	 */
	public void setOutputTimeline(Timeline outputTimeline)
	{
		//==========================================================================================
		// Remove last timeline change observer.
		
		if (this.outputTimeline != null)
		{
			this.outputTimeline.removeTimelineChangedListerner(this);
		}
		
		//------------------------------------------------------------------------------------------
		this.outputTimeline = outputTimeline;
		
		//------------------------------------------------------------------------------------------
		// Register new timeline change observer.
		if (this.outputTimeline != null)
		{
			this.outputTimeline.addTimelineChangedListerner(this);
		}
		
		//==========================================================================================
	}

	/* (non-Javadoc)
	 * @see de.schmiereck.noiseComp.timeline.TimelineChangedListernerInterface#notifyTimelineChanged(de.schmiereck.noiseComp.timeline.Timeline, float, float)
	 */
	@Override
	public void notifyTimelineChanged(Timeline timeline, float changedStartTimePos, float changedEndTimePos)
	{
		//==========================================================================================
		Generator generator = timeline.getGenerator();
		
		if (generator != null)
		{
			this.notifyGeneratorChanged(generator, changedStartTimePos, changedEndTimePos);
		}
		
		//==========================================================================================
	}
}
